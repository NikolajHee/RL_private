# This file may not be shared/redistributed without permission. Please read copyright notice in the git repo. If this file contains other copyright notices disregard this text.
"""
This project resembles the Inventory-control problem discussed in (Her23, Subsection 5.1.2) but with more complicated rules.
If you are stuck, the inventory-control problem will be a good place to start.

I recommend to use the DP_stochastic function (as we did with the inventory-control example). This means
your main problem is to build appropriate DPModel-classes to represent the different problems.
References:
  [Her23] Tue Herlau. Sequential decision making. (See 02465_Notes.pdf), 2023.
"""
from irlc.ex02.dp_model import DPModel
from irlc.ex02.dp import DP_stochastic
import matplotlib.pyplot as plt
from scipy.stats import binom
from irlc import savepdf
import numpy as np

def plot_policy(pi, title, pdf):
    """ Helper function to plot the policy functions pi, as generated by the DP_stochastic function. This function
    can be used to visualize which actions are taken in which state (y-axis) at which time step (x-axis). """
    N = len(pi)
    W = max(pi[0].keys())
    A = np.zeros((W, N))
    for i in range(W):
        for j in range(N):
            A[i, j] = pi[j][i]
    plt.imshow(A)
    plt.title(title)
    savepdf(pdf)
    plt.show()

# TODO: 51 lines missing.
#raise NotImplementedError("Insert your solution and remove this error.")
class kiosk_1(DPModel): 
    def __init__(self, N=14):
        #super().__init__(N=N)
        self.N = N

    def A(self, x, k): # Action space A_k(x) 
        return list(range(15+1))

    def S(self, k): # State space S_k 
        return list(range(20+1))

    def g(self, x, u, w, k): # Cost function g_k(x,u,w) 
        amount_sold = (w + min(x+u-w,0))
        return - amount_sold * 2.1 + u * 1.5

    def f(self, x, u, w, k): # Dynamics f_k(x,u,w) 
        return max(0, min(20, x - w + u))

    def Pw(self, x, u, k): # Distribution over random disturbances 
        return {0: 3/10, 3:6/10, 6:1/10}

    def gN(self, x): 
        return 0

class kiosk_2(DPModel): 
    def __init__(self, N=14):
        #super().__init__(N=N)
        self.N = N

    def A(self, x, k): # Action space A_k(x) 
        return list(range(15+1))

    def S(self, k): # State space S_k 
        return list(range(20+1))

    def g(self, x, u, w, k): # Cost function g_k(x,u,w) 
        amount_sold = (w + min(x+u-w,0))
        excess_blaster = (x - w + u - 20) if ((x - w + u) > 20) else 0
        return - amount_sold * 2.1 + u * 1.5 + excess_blaster * 3

    def f(self, x, u, w, k): # Dynamics f_k(x,u,w) 
        return max(0, min(20, x - w + u))

    def Pw(self, x, u, k): # Distribution over random disturbances 
        #return {0: 3/10, 3:6/10, 6:1/10}
        return {w: binom.pmf(w, 20, 1/5) for w in range(21)}

    def gN(self, x): 
        return 0



def warmup_states(): 
    # TODO: 1 lines missing.
    return set(range(20+1)) # plus 1 as it contains 0
    #raise NotImplementedError("return state set")

def warmup_actions(): 
    # TODO: 1 lines missing.
    return set(range(15+1)) # plus 1 as it contains 0
    #raise NotImplementedError("return action set")

def solve_kiosk_1(): 
    # TODO: 1 lines missing.
    return DP_stochastic(kiosk_1())
    ##raise NotImplementedError("Return cost and policy here (same format as DP_stochastic)")

def solve_kiosk_2(): 
    # TODO: 1 lines missing.
    return DP_stochastic(kiosk_2())
    #raise NotImplementedError("Return cost and policy here (same format as DP_stochastic)")


def main():
    # Problem 14
    print("Available states S_0:", warmup_states())
    print("Available actions A_0(x_0):", warmup_actions())

    J, pi = solve_kiosk_1() # Problem 16
    print("Kiosk1: Expected profits: ", -J[0][0], " imperial credits")
    plot_policy(pi, "Kiosk1", "Latex/figures/kiosk1")
    plt.show()

    J, pi = solve_kiosk_2() # Problem 17
    print("Kiosk 2: Expected profits: ", -J[0][0], " imperial credits")
    plot_policy(pi, "Kiosk2", "Latex/figures/kiosk2")
    plt.show()


if __name__ == "__main__":
    main()
